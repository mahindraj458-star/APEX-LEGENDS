<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>APEX // DRIVE ENGINE PRO</title>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&family=Syncopate:wght@700&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    
    <style>
        :root { --apex-red: #ff1111; --apex-cyan: #00f2ff; --bg-sky: #87CEEB; }
        body { margin: 0; overflow: hidden; background: #87CEEB; font-family: 'Rajdhani', sans-serif; color: #fff; text-transform: uppercase; }
        
        .overlay { 
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; 
            background: radial-gradient(circle at center, #111 0%, #000 100%); 
            z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; 
        }
        
        h1 { font-family: 'Syncopate', sans-serif; color: var(--apex-red); letter-spacing: 8px; margin-bottom: 20px; text-align: center;}
        
        #hangar-ui { width: 90%; max-width: 1200px; max-height: 80vh; overflow-y: auto; padding: 20px; }
        .vehicle-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 25px; }
        
        .vehicle-card {
            background: rgba(255,255,255,0.03);
            border-left: 4px solid #222;
            padding: 20px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .vehicle-card:hover { 
            background: rgba(0,242,255,0.05); 
            border-left-color: var(--apex-cyan);
            transform: translateX(10px);
        }
        .vehicle-card h3 { font-family: 'Syncopate'; font-size: 1.1rem; margin: 0 0 15px 0; color: #fff; }
        
        .stat-label { display: flex; justify-content: space-between; font-size: 0.7rem; color: #aaa; margin-bottom: 4px; }

        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; z-index: 10; }
        
        .speed-panel { position: absolute; bottom: 40px; left: 40px; }
        .speed-val { font-size: 6rem; font-family: 'Syncopate'; font-weight: 700; line-height: 0.8; text-shadow: 2px 2px 10px rgba(0,0,0,0.5); }
        .speed-unit { font-size: 1.5rem; color: var(--apex-red); margin-left: 10px; }
        
        .performance-timer {
            position: absolute; top: 40px; left: 40px;
            background: rgba(0,0,0,0.7); padding: 15px; border-left: 3px solid var(--apex-red);
        }
        .timer-label { font-size: 0.6rem; color: #888; letter-spacing: 2px; }
        .timer-val { font-size: 1.8rem; font-family: 'Syncopate'; color: var(--apex-cyan); }

        .telemetry { position: absolute; bottom: 40px; right: 40px; text-align: right; background: rgba(0,0,0,0.6); padding: 20px; border-right: 4px solid var(--apex-cyan); }
        .tel-row { margin-bottom: 10px; }
        .tel-label { font-size: 0.7rem; color: #666; }
        .tel-val { font-size: 1.2rem; font-family: 'Syncopate'; color: #fff; }

        .hint-box { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); padding: 10px 30px; border: 1px solid #333; font-size: 0.8rem; letter-spacing: 2px; text-align: center; }
        .hint-box b { color: var(--apex-red); }

        .btn-ui {
            pointer-events: auto;
            padding: 10px 20px; border: 1px solid var(--apex-red); background: rgba(0,0,0,0.5); 
            color: #fff; font-family: 'Syncopate'; cursor: pointer; letter-spacing: 1px;
            font-size: 0.7rem; transition: 0.2s;
        }
        .btn-ui:hover { background: var(--apex-red); color: black; }

        #btn-load { display: none; padding: 15px 40px; font-size: 1rem; }
        #change-model-btn { position: absolute; top: 120px; right: 40px; border-color: var(--apex-cyan); }
    </style>
</head>
<body>

    <div id="loader-screen" class="overlay">
        <h1 id="main-title">APEX // DRIVE</h1>
        <div id="status-log">CONNECTING TO MANIFEST...</div>
        <button id="btn-load" class="btn-ui" onclick="location.reload()">RETRY CONNECTION</button>
    </div>

    <div id="selection-screen" class="overlay" style="display:none; justify-content: flex-start; padding-top: 5vh;">
        <h1>VEHICLE SELECTION</h1>
        <div id="hangar-ui">
            <div class="vehicle-grid" id="vehicleGrid"></div>
        </div>
    </div>

    <div id="hud">
        <button id="change-model-btn" class="btn-ui" onclick="returnToSelection()">CHANGE MODEL</button>

        <div class="hint-box">
            WASD: <b>DRIVE</b> | T: <b>RESET TIMER</b> | C: <b>CAM</b> | R: <b>ROTATE</b> | SPACE: <b>E-BRAKE</b>
        </div>

        <div class="performance-timer">
            <div class="timer-label">0-60 TEST</div>
            <div class="timer-val" id="timer060">--:--</div>
            <div class="timer-label" style="margin-top:10px;">VEHICLE LIMIT</div>
            <div class="timer-val" id="topSpeedLimit" style="color: #fff">0 MPH</div>
        </div>

        <div class="speed-panel">
            <div class="speed-val" id="speedDisplay">000</div>
            <div class="speed-unit">MPH <span id="gearDisplay" style="color:white; margin-left:20px;">GEAR N</span></div>
        </div>

        <div class="telemetry">
            <div class="tel-row">
                <div class="tel-label">MODEL HP</div>
                <div class="tel-val" id="hpDisplay">-- HP</div>
            </div>
            <div class="tel-row">
                <div class="tel-label">CURB WEIGHT</div>
                <div class="tel-val" id="massDisplay">-- KG</div>
            </div>
        </div>
    </div>

    <script>
        const GITHUB_USER = "mahindraj458-star";
        const GITHUB_REPO = "APEX-LEGENDS";
        
        let vehiclePack = [];
        let currentVehicle = null;
        let carGroup = new THREE.Group(); 
        let carPivot = new THREE.Group(); 
        let carModel = null; 
        
        let velocity = 0;
        let camMode = 0;
        let autoRotate = true; 
        
        let timerRunning = false;
        let startTime = 0;
        let final060 = null;

        const ROAD_LIMIT = 12.5; // Physics boundary for barriers

        const keys = { w: false, a: false, s: false, d: false, ' ': false };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 50, 600);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);
        
        const ambient = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambient);

        const sunLight = new THREE.DirectionalLight(0xffffcc, 1.0);
        sunLight.position.set(100, 200, 100);
        scene.add(sunLight);

        function createSun() {
            const sunCanvas = document.createElement('canvas');
            sunCanvas.width = 128; sunCanvas.height = 128;
            const ctx = sunCanvas.getContext('2d');
            const grad = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            grad.addColorStop(0, 'white');
            grad.addColorStop(0.2, '#fff600');
            grad.addColorStop(0.5, 'rgba(255, 240, 0, 0.5)');
            grad.addColorStop(1, 'rgba(255, 240, 0, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,128,128);
            
            const tex = new THREE.CanvasTexture(sunCanvas);
            const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
            const sprite = new THREE.Sprite(mat);
            sprite.position.set(200, 300, -500);
            sprite.scale.set(100, 100, 1);
            scene.add(sprite);
        }
        createSun();

        function createWorld() {
            const groundGeo = new THREE.PlaneGeometry(10000, 10000);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x4a7c44 });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const roadGeo = new THREE.PlaneGeometry(25, 10000);
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const road = new THREE.Mesh(roadGeo, roadMat);
            road.rotation.x = -Math.PI / 2;
            road.position.y = 0.05;
            road.receiveShadow = true;
            scene.add(road);

            for(let i = -5000; i < 5000; i += 40) {
                const lineGeo = new THREE.PlaneGeometry(0.6, 15);
                const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
                const line = new THREE.Mesh(lineGeo, lineMat);
                line.rotation.x = -Math.PI / 2;
                line.position.set(0, 0.1, i);
                scene.add(line);
            }

            for(let i = -5000; i < 5000; i += 10) {
                const barrierGeo = new THREE.BoxGeometry(0.5, 0.8, 10);
                const barrierMat = new THREE.MeshStandardMaterial({ color: 0x999999 });
                const leftB = new THREE.Mesh(barrierGeo, barrierMat);
                leftB.position.set(-13, 0.4, i);
                scene.add(leftB);
                const rightB = new THREE.Mesh(barrierGeo, barrierMat);
                rightB.position.set(13, 0.4, i);
                scene.add(rightB);
            }

            const objects = [
                { color: '#8b4513', type: 'house' },
                { color: '#228b22', type: 'tree' },
                { color: '#32cd32', type: 'grass' }
            ];

            for(let i = -5000; i < 5000; i += 50) {
                const side = Math.random() > 0.5 ? 1 : -1;
                const xPos = (25 + Math.random() * 50) * side;
                const obj = objects[Math.floor(Math.random() * objects.length)];
                const canvas = document.createElement('canvas');
                canvas.width = 256; canvas.height = 256;
                const ctx = canvas.getContext('2d');
                if(obj.type === 'house') {
                    ctx.fillStyle = obj.color; ctx.fillRect(50, 100, 150, 150);
                    ctx.fillStyle = '#5c2e0a'; ctx.beginPath(); ctx.moveTo(30, 100); ctx.lineTo(226, 100); ctx.lineTo(128, 20); ctx.closePath(); ctx.fill();
                } else if(obj.type === 'tree') {
                    ctx.fillStyle = '#5c4033'; ctx.fillRect(118, 150, 20, 106);
                    ctx.fillStyle = obj.color; ctx.beginPath(); ctx.arc(128, 120, 80, 0, Math.PI*2); ctx.fill();
                } else {
                    ctx.strokeStyle = obj.color; ctx.lineWidth = 10; ctx.beginPath(); ctx.moveTo(128, 256); ctx.lineTo(100, 150); ctx.moveTo(128, 256); ctx.lineTo(128, 120); ctx.moveTo(128, 256); ctx.lineTo(156, 150); ctx.stroke();
                }
                const tex = new THREE.CanvasTexture(canvas);
                const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
                const sprite = new THREE.Sprite(mat);
                sprite.position.set(xPos, 5, i);
                sprite.scale.set(15, 15, 1);
                scene.add(sprite);
            }
        }
        createWorld();

        window.onload = () => loadData();

        async function loadData() {
            try {
                const response = await fetch(`https://raw.githubusercontent.com/${GITHUB_USER}/${GITHUB_REPO}/main/collection.apex?t=${Date.now()}`);
                const data = await response.json();
                vehiclePack = data.units || [];
                showHangar();
            } catch (e) {
                document.getElementById('status-log').innerText = "FAILED TO READ APEX FILE.";
                document.getElementById('btn-load').style.display = "block";
            }
        }

        function showHangar() {
            document.getElementById('hud').style.display = "none";
            document.getElementById('loader-screen').style.display = "none";
            document.getElementById('selection-screen').style.display = "flex";
            const gridEl = document.getElementById('vehicleGrid');
            gridEl.innerHTML = "";
            
            vehiclePack.forEach((unit, idx) => {
                const card = document.createElement('div');
                card.className = "vehicle-card";
                card.onclick = () => deploy(idx);
                card.innerHTML = `
                    <h3>${unit.name}</h3>
                    <div class="stat-label"><span>POWER</span><span>${unit.stats.hp} HP</span></div>
                    <div class="stat-label"><span>WEIGHT</span><span>${unit.stats.mass} KG</span></div>
                    <div class="stat-label"><span>FILE TOP SPEED</span><span>${unit.stats.topSpeed} MPH</span></div>
                `;
                gridEl.appendChild(card);
            });
        }

        function returnToSelection() {
            velocity = 0;
            document.getElementById('hud').style.display = "none";
            document.getElementById('selection-screen').style.display = "flex";
            if(carGroup) scene.remove(carGroup);
        }

        function deploy(idx) {
            currentVehicle = vehiclePack[idx];
            document.getElementById('selection-screen').style.display = "none";
            document.getElementById('loader-screen').style.display = "flex";
            document.getElementById('status-log').innerText = `LOADING ${currentVehicle.name}...`;
            
            const loader = new THREE.GLTFLoader();
            loader.load(currentVehicle.modelUrl, (gltf) => {
                initWorld(gltf.scene);
            }, undefined, () => {
                const g = new THREE.BoxGeometry(2, 1, 4);
                const m = new THREE.MeshStandardMaterial({ color: 0xcc0000 });
                initWorld(new THREE.Mesh(g, m));
            });
        }

        function initWorld(model) {
            scene.remove(carGroup);
            carPivot = new THREE.Group();
            carGroup = new THREE.Group();
            
            carModel = model;
            const box = new THREE.Box3().setFromObject(carModel);
            carModel.position.y = -box.min.y; 
            
            carPivot.add(carModel);
            carGroup.add(carPivot);
            
            carGroup.position.set(0, 0, 0);
            carGroup.rotation.y = 0;
            carPivot.rotation.y = 0;

            scene.add(carGroup);
            
            document.getElementById('loader-screen').style.display = "none";
            document.getElementById('hud').style.display = "block";
            
            document.getElementById('hpDisplay').innerText = `${currentVehicle.stats.hp} HP`;
            document.getElementById('massDisplay').innerText = `${currentVehicle.stats.mass} KG`;
            document.getElementById('topSpeedLimit').innerText = `${currentVehicle.stats.topSpeed} MPH`;
            
            velocity = 0;
            resetTimer();
        }

        function resetTimer() {
            timerRunning = false;
            final060 = null;
            document.getElementById('timer060').innerText = "--:--";
            document.getElementById('timer060').style.color = "#fff";
        }

        window.addEventListener('keydown', (e) => { 
            const k = e.key.toLowerCase();
            keys[k] = true;
            if (k === 't') resetTimer();
            if (k === 'c') camMode = (camMode + 1) % 3;
            if (k === 'r') {
                autoRotate = !autoRotate;
                if(!autoRotate) carPivot.rotation.y = 0;
            }
        });
        window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            if (carGroup && currentVehicle) {
                updatePhysics(dt);
                updateCamera();
                
                if(autoRotate && Math.abs(velocity) < 0.2) {
                    carPivot.rotation.y += 0.8 * dt;
                } else if (!autoRotate) {
                    carPivot.rotation.y = THREE.MathUtils.lerp(carPivot.rotation.y, 0, 0.1);
                }
            }
            renderer.render(scene, camera);
        }
        animate();

        function updatePhysics(dt) {
            const s = currentVehicle.stats;
            const topSpeedMs = s.topSpeed / 2.237;
            const weightRatio = s.hp / s.mass;
            const speedFactor = 1.0 - (Math.abs(velocity) / topSpeedMs);
            const accelBase = weightRatio * 40; 
            
            if (keys.w) {
                velocity += accelBase * Math.max(0.1, speedFactor) * dt;
                if (!timerRunning && velocity > 0.5 && !final060) {
                    timerRunning = true;
                    startTime = Date.now();
                }
            } else if (keys.s) {
                if (velocity > 0.5) velocity -= (s.hp / s.mass) * 10 * dt; // Simple brake
                else velocity -= (accelBase * 0.5) * dt;
            } else {
                velocity *= 0.985;
            }

            if (keys[' ']) velocity *= 0.9;
            velocity = Math.max(Math.min(velocity, topSpeedMs), -topSpeedMs * 0.2);

            const turnSpeed = (2.0 - (Math.abs(velocity) / topSpeedMs) * 1.5);
            if (Math.abs(velocity) > 0.1) {
                const dir = velocity > 0 ? 1 : -1;
                if (keys.a) carGroup.rotation.y += turnSpeed * dt * dir;
                if (keys.d) carGroup.rotation.y -= turnSpeed * dt * dir;
            }

            carGroup.translateZ(velocity * dt);

            // BARRIER PHYSICS - Prevent car from moving beyond road edges
            if (carGroup.position.x > ROAD_LIMIT) carGroup.position.x = ROAD_LIMIT;
            if (carGroup.position.x < -ROAD_LIMIT) carGroup.position.x = -ROAD_LIMIT;

            carPivot.rotation.z = THREE.MathUtils.lerp(carPivot.rotation.z, (keys.a ? 0.05 : keys.d ? -0.05 : 0), 0.1);

            const mph = Math.abs(velocity * 2.237);
            document.getElementById('speedDisplay').innerText = Math.floor(mph).toString().padStart(3, '0');
            
            if (timerRunning) {
                const elapsed = (Date.now() - startTime) / 1000;
                if (mph >= 60) {
                    timerRunning = false;
                    final060 = elapsed.toFixed(2);
                    document.getElementById('timer060').innerText = final060 + "s";
                    document.getElementById('timer060').style.color = "var(--apex-cyan)";
                } else {
                    document.getElementById('timer060').innerText = elapsed.toFixed(2) + "s";
                }
            }

            let gear = "N";
            if (velocity > 0.1) gear = Math.min(6, Math.ceil(mph / (s.topSpeed/6))) || 1;
            if (velocity < -0.1) gear = "R";
            document.getElementById('gearDisplay').innerText = "GEAR " + gear;
        }

        function updateCamera() {
            let offset, look;
            switch(camMode) {
                case 0: // Chase
                    offset = new THREE.Vector3(0, 4, -12).applyMatrix4(carGroup.matrixWorld);
                    look = new THREE.Vector3(0, 1, 10).applyMatrix4(carGroup.matrixWorld);
                    break;
                case 1: // Top Down
                    offset = new THREE.Vector3(0, 45, 5).applyMatrix4(carGroup.matrixWorld);
                    look = carGroup.position;
                    break;
                case 2: // Dashboard
                    offset = new THREE.Vector3(0, 1.5, 0.5).applyMatrix4(carGroup.matrixWorld);
                    look = new THREE.Vector3(0, 1, 20).applyMatrix4(carGroup.matrixWorld);
                    break;
            }
            camera.position.lerp(offset, 0.1);
            camera.lookAt(look);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
